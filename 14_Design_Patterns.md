## What Are Design Patterns?

Design patterns are proven, time-tested solutions to common software design problems. They're like templates that help developers write code that is more reusable, maintainable, and scalable.

---

### Simple Definition:

> "Design patterns are best practices that solve recurring design problems in software development."

---

### 🏠 Real-Life Analogy: Building a House

When a builder constructs a house, they don't reinvent the structure every time. They use predefined house layouts like 1BHK, 2BHK, or duplex.

These designs:

* Are tried and tested
* Save time
* Ensure quality

**Similarly,** software engineers use design patterns to solve problems efficiently and reliably.

---

### 🌟 Why Use Design Patterns?

* Promote **code reusability**
* Make code **easier to maintain**
* Improve **team collaboration**
* Follow **industry best practices**
* Prepare code for **future changes**

---

### 📚 Types of Design Patterns (3 Main Categories)

1. **Creational Patterns** – Focus on object creation mechanisms

   * Examples: Singleton, Factory, Builder

2. **Structural Patterns** – Deal with object composition and relationships

   * Examples: Adapter, Decorator, Composite

3. **Behavioral Patterns** – Focus on communication between objects

   * Examples: Observer, Strategy, Command

---

### 🧠 One-Line Summary:

> Design patterns are reusable solutions created by experienced developers to solve common design problems. Instead of reinventing the wheel, apply the right pattern and move forward with confidence.

---

## ✅ 3 Main Types of Design Patterns

Design Patterns are broadly categorized into three main types:

### 1. Creational Design Patterns

These patterns deal with **how objects are created**. They provide flexibility and control over object creation, making it more reusable and adaptable.

**Real-life Analogy:**
When you make a pizza, you may use a step-by-step builder (custom pizza) or get a ready-made one from a factory (factory method).

**Common Patterns:**

| Pattern Name     | Use Case Description                                      |
| ---------------- | --------------------------------------------------------- |
| Singleton        | Ensure a class has only one instance                      |
| Factory Method   | Delegate object creation to a separate class              |
| Builder          | Create complex objects step-by-step                       |
| Prototype        | Clone an existing object                                  |
| Abstract Factory | Create families of related objects (Factory of factories) |

---

### 2. Structural Design Patterns

These patterns focus on **how objects and classes are composed** to form larger structures. They ensure that if one part changes, others don’t break.

**Real-life Analogy:**
Your house layout — fridge in kitchen, bed in bedroom, balcony attached to room — structured object layout.

**Common Patterns:**

| Pattern Name | Use Case Description                                        |
| ------------ | ----------------------------------------------------------- |
| Adapter      | Bridge two incompatible systems                             |
| Decorator    | Add responsibilities to objects without altering their core |
| Composite    | Create tree structures to represent part-whole hierarchies  |
| Proxy        | Add a surrogate for controlling access to another object    |
| Facade       | Provide a simplified interface to a complex system          |
| Flyweight    | Share common state between many objects to save memory      |
| Bridge       | Separate abstraction from its implementation                |

---

### 3. Behavioral Design Patterns

These patterns define **how objects communicate and interact** with one another.

**Real-life Analogy:**
In school, a teacher instructs and students listen. A manager assigns tasks and employees perform them.

**Common Patterns:**

| Pattern Name            | Use Case Description                                               |
| ----------------------- | ------------------------------------------------------------------ |
| Observer                | Notify all dependents when one object changes                      |
| Strategy                | Swap between different algorithms at runtime                       |
| Command                 | Encapsulate a request as an object                                 |
| State                   | Allow an object to change its behavior based on internal state     |
| Iterator                | Sequentially access elements of a collection                       |
| Mediator                | Centralize communication between objects                           |
| Template Method         | Define algorithm skeleton in superclass, defer steps to subclasses |
| Chain of Responsibility | Pass request through a chain of handlers                           |

---

### 🧠 One-Line Summary:

| Type       | Purpose                               |
| ---------- | ------------------------------------- |
| Creational | Best ways to create objects           |
| Structural | Arrangement and connection of objects |
| Behavioral | How objects communicate and interact  |

---

